#!/usr/bin/env python3

import rospy
import csv
import cv2
import math
import os
import requests
import queue
import shlex
import subprocess
import tempfile
import threading
import traceback
import time
import datetime
import logging
import roslib
import sys
import yaml
import olympe

from std_msgs.msg import UInt8, UInt16, UInt32, UInt64, Int8, Float32, String, Header, Time, Bool
from geometry_msgs.msg import PoseStamped, PointStamped, QuaternionStamped, TwistStamped, Vector3Stamped, Quaternion, Twist, Vector3
from nav_msgs.msg import Odometry
from sensor_msgs.msg import Image, CameraInfo, NavSatFix
from std_srvs.srv import Empty, SetBool
from tf.transformations import euler_from_quaternion
from cv_bridge import CvBridge, CvBridgeError

from olympe.messages.drone_manager import connection_state
from olympe.messages.ardrone3.Piloting import TakeOff, UserTakeOff, Landing, Emergency, PCMD, NavigateHome
from olympe.messages.ardrone3.PilotingState import FlyingStateChanged, PositionChanged, SpeedChanged, AttitudeChanged, AltitudeChanged, GpsLocationChanged
from olympe.messages.ardrone3.PilotingSettings import MaxTilt, MaxDistance, MaxAltitude, NoFlyOverMaxDistance, BankedTurn
from olympe.messages.ardrone3.PilotingSettingsState import MaxTiltChanged, MaxDistanceChanged, MaxAltitudeChanged, NoFlyOverMaxDistanceChanged, BankedTurnChanged
from olympe.messages.ardrone3.SpeedSettings import MaxVerticalSpeed, MaxRotationSpeed, MaxPitchRollRotationSpeed
from olympe.messages.ardrone3.SpeedSettingsState import MaxVerticalSpeedChanged, MaxRotationSpeedChanged, MaxPitchRollRotationSpeedChanged
from olympe.messages.ardrone3.GPSSettingsState import GPSFixStateChanged
from olympe.messages.ardrone3.GPSState import NumberOfSatelliteChanged
from olympe.messages.piloting_style import set_style
from olympe.messages.controller_info import validity_from_drone
from olympe.messages.precise_home import set_mode as precise_home_set_mode
from olympe.messages.rth import return_to_home, abort, set_ending_behavior, set_ending_hovering_altitude, set_min_altitude
from olympe.messages.skyctrl.CoPiloting import setPilotingSource
from olympe.messages.skyctrl.CoPilotingState import pilotingSource
from olympe.messages.skyctrl.Common import AllStates
from olympe.messages.skyctrl.CommonState import AllStatesChanged
from olympe.messages import gimbal, camera, mapper, leds
from olympe.media import download_media, indexing_state, delete_media, delete_all_media
from olympe.messages.mediastore import state as mediastore_state_message
from olympe.enums.ardrone3.PilotingState import AlertStateChanged_State, ForcedLandingAutoTrigger_Reason
from olympe.enums.camera import availability, state
from olympe.enums.piloting_style import style
from olympe.enums.precise_home import mode as precise_home_mode
from olympe.enums.mediastore import state as mediastore_state_enum

from dynamic_reconfigure.server import Server
from olympe_bridge.cfg import setAnafiConfig
from olympe_bridge.msg import PilotingCommand, MoveByCommand, MoveToCommand, CameraCommand, GimbalCommand, SkycontrollerCommand, TargetTrajectory
from olympe_bridge.srv import PilotedPOI, FlightPlan, FollowMe, Location, String as StringSRV

import olympe_bridge

olympe.log.update_config({"loggers": {"olympe": {"level": "ERROR"}}})


def bound(value, value_min, value_max):
	return min(max(value, value_min), value_max)


def bound_percentage(value):
	return bound(value, -100, 100)


class Anafi(threading.Thread):
	models = {2324:"4k", 2329:"thermal", 2334:"usa", 0000:"ai"}

	def __init__(self):
		# Publishers
		self.pub_image = rospy.Publisher("camera/image", Image, queue_size=1)
		self.pub_camera_info = rospy.Publisher("camera/camera_info", CameraInfo, queue_size=1)
		self.pub_time = rospy.Publisher("time", Time, queue_size=1)
		self.pub_attitude = rospy.Publisher("drone/attitude", QuaternionStamped, queue_size=1)
		self.pub_altitude = rospy.Publisher("drone/altitude", Float32, queue_size=1)
		self.pub_speed = rospy.Publisher("drone/speed", Vector3Stamped, queue_size=1)
		self.pub_link_goodput = rospy.Publisher("link/goodput", UInt16, queue_size=1)
		self.pub_link_quality = rospy.Publisher("link/quality", UInt8, queue_size=1)
		self.pub_wifi_rssi = rospy.Publisher("link/rssi", Int8, queue_size=1)
		self.pub_battery = rospy.Publisher("drone/battery", UInt8, queue_size=1)
		self.pub_state = rospy.Publisher("drone/state", String, queue_size=1)
		self.pub_rpy = rospy.Publisher("drone/rpy", Vector3Stamped, queue_size=1)
		self.pub_camera_attitude = rospy.Publisher("camera/attitude", QuaternionStamped, queue_size=1)
		self.pub_camera_base_attitude = rospy.Publisher("camera/base/attitude", QuaternionStamped, queue_size=1)
		self.pub_exposure_time = rospy.Publisher("camera/exposure_time", Float32, queue_size=1)
		self.pub_iso_gain = rospy.Publisher("camera/iso_gain", UInt16, queue_size=1)
		self.pub_awb_r_gain = rospy.Publisher("camera/awb_r_gain", Float32, queue_size=1)
		self.pub_awb_b_gain = rospy.Publisher("camera/awb_b_gain", Float32, queue_size=1)
		self.pub_hfov = rospy.Publisher("camera/hfov", Float32, queue_size=1)
		self.pub_vfov = rospy.Publisher("camera/vfov", Float32, queue_size=1)
		self.pub_gps_fix = rospy.Publisher("drone/gps/fix", Bool, queue_size=1)
		self.pub_steady = rospy.Publisher("drone/steady", Bool, queue_size=1)
		self.pub_battery_health = rospy.Publisher("battery/health", UInt8, queue_size=1)
		self.pub_home_location = rospy.Publisher("home/location", PointStamped, queue_size=1)
		self.pub_skyctrl_command = rospy.Publisher("skycontroller/command", SkycontrollerCommand, queue_size=1)

		# Subscribers
		rospy.Subscriber("drone/rpyt", PilotingCommand, self.rpyt_callback)
		rospy.Subscriber("drone/moveto", MoveToCommand, self.moveTo_callback)
		rospy.Subscriber("drone/moveby", MoveByCommand, self.moveBy_callback)
		rospy.Subscriber("camera/cmd", CameraCommand, self.zoom_callback)
		rospy.Subscriber("gimbal/cmd", GimbalCommand, self.gimbal_callback)
		
		# Services
		rospy.Service('discover_drones', Empty, self.discover_drones)
		rospy.Service('forget_drone', StringSRV, self.forget_drone)
		rospy.Service('takeoff', Empty, self.takeoff)
		rospy.Service('arm', SetBool, self.arm)
		rospy.Service('land', Empty, self.land)
		rospy.Service('emergency', Empty, self.emergency)
		rospy.Service('halt', Empty, self.halt)
		rospy.Service('navigate_home', SetBool, self.navigate_home)
		rospy.Service('start_piloted_POI', PilotedPOI, self.start_piloted_POI)
		rospy.Service('stop_piloted_POI', Empty, self.stop_piloted_POI)
		rospy.Service('rth', Empty, self.rth)
		rospy.Service('set_home', Location, self.set_home)
		rospy.Service('flightplan_upload', FlightPlan, self.flightplan_upload)
		rospy.Service('flightplan_start', FlightPlan, self.flightplan_start)
		rospy.Service('flightplan_pause', Empty, self.flightplan_pause)
		rospy.Service('flightplan_stop', Empty, self.flightplan_stop)
		rospy.Service('followme_start', FollowMe, self.followme_start)
		rospy.Service('followme_stop', Empty, self.followme_stop)
		rospy.Service('offboard', SetBool, self.offboard)
		rospy.Service('calibrate_magnetometer', Empty, self.calibrate_magnetometer)
		rospy.Service('calibrate_gimbal', Empty, self.calibrate_gimbal)
		rospy.Service('reset_zoom', Empty, self.reset_zoom)
		rospy.Service('reset_gimbal', Empty, self.reset_gimbal)	
		rospy.Service('take_photo', Empty, self.take_photo)
		rospy.Service('stop_photo', Empty, self.stop_photo)
		rospy.Service('start_recording', Empty, self.start_recording)
		rospy.Service('stop_recording', Empty, self.stop_recording)
		rospy.Service('download_media', Empty, self.download_media)
		rospy.Service('reboot', Empty, self.reboot)
		rospy.Service('format', Empty, self.format)
		
		# Messages
		self.header = Header()
		self.msg_camera_info = CameraInfo()
		self.msg_time = Time()
		self.msg_attitude = QuaternionStamped()
		self.msg_rpy = Vector3Stamped()
		self.msg_speed = Vector3Stamped()
		self.msg_home_location = PointStamped()
		self.msg_skycontroller = SkycontrollerCommand()
		self.msg_skycontroller.header.frame_id = 'body'	

		# Defined in the launch file
		self.model = rospy.get_param("model")
		self.ip = rospy.get_param("ip")
		self.drone_serial = rospy.get_param("drone_serial")
		self.wifi_key = rospy.get_param("wifi_key")
		self.rest_api_version = rospy.get_param("rest_api_version")
		self.skycontroller_enabled = rospy.get_param("skycontroller_enabled")
		
		if self.skycontroller_enabled:  # connect to SkyController
			rospy.loginfo("Connecting through SkyController")
		else:  # connect to Anafi
			rospy.loginfo("Connecting directly to Anafi")
		self.drone = olympe.Drone(self.ip)
		self.skyctrl = self.drone

		# Create event listeners
		self.event_listener_anafi = olympe_bridge.EventListenerAnafi(self)
		self.event_listener_skycontroller = olympe_bridge.EventListenerSkyController(self)

		self.bridge = CvBridge()  # to convert OpenCV images to ROS images

		self.state = 'LANDED'
		self.gps_fixed = False

		rospy.on_shutdown(self.stop)

		self.connect()

		self.srv = Server(setAnafiConfig, self.reconfigure_callback)

		if self.skycontroller_enabled:
			#model = self.drone.get_state(olympe.messages.drone_manager.known_drone_item).popitem(last=False)[1]['model'] # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.known_drone_item
			model = self.drone.get_state(olympe.messages.mapper.active_product)['product'] # https://developer.parrot.com/docs/olympe/arsdkng_mapper.html#olympe.messages.mapper.active_product
			self.model = self.models.get(model, self.model)
		rospy.loginfo('Drone model: ' + self.model)

		if self.model in {"4k", "thermal", "usa", "ai"}:
			with open(os.path.abspath(os.path.dirname(__file__) + "/../../config/camera_" + self.model + ".yaml"), "r") as file_handle: # load camera info from file
				camera_info = yaml.load(file_handle, Loader=yaml.FullLoader)
			rospy.loginfo("Camera info loaded from " + os.path.abspath(os.path.dirname(__file__) + "/../../config/camera_" + self.model + ".yaml"))
			# Parse camera info		
			self.msg_camera_info.width = camera_info['image_width']
			self.msg_camera_info.height = camera_info['image_height']
			self.msg_camera_info.K = camera_info['camera_matrix']['data']
			self.msg_camera_info.D = camera_info['distortion_coefficients']['data']
			self.msg_camera_info.R = camera_info['rectification_matrix']['data']
			self.msg_camera_info.P = camera_info['projection_matrix']['data']
			self.msg_camera_info.distortion_model = camera_info['distortion_model']
		else:
			rospy.logerr("Model " + self.model + " is not supported")
		
		self.drone(camera.set_antiflicker_mode(mode="auto")) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_antiflicker_mode
		self.drone(camera.set_white_balance(cam_id=0, mode="automatic", temperature="t_8000")) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_white_balance
		self.drone(camera.set_zoom_velocity_quality_degradation(cam_id=0, allow=1)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_zoom_velocity_quality_degradation
		self.drone(NoFlyOverMaxDistance(shouldNotFlyOver=1)) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.NoFlyOverMaxDistance
		self.drone(olympe.messages.user_storage.start_monitoring(period=1)) # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.messages.user_storage.start_monitoring
		
		if self.skycontroller_enabled:
			self.drone(olympe.messages.skyctrl.Calibration.enableMagnetoCalibrationQualityUpdates(enable=1)) # https://developer.parrot.com/docs/olympe/arsdkng_skyctrl_calibration.html#olympe.messages.skyctrl.Calibration.enableMagnetoCalibrationQualityUpdates
		
		rospy.logdebug('Drone name: ' + str(self.drone.get_state(olympe.messages.common.SettingsState.ProductNameChanged)['name'])) # https://developer.parrot.com/docs/olympe/arsdkng_common_settings.html#olympe.messages.common.SettingsState.ProductNameChanged
		rospy.logdebug('Drone serial: ' + str(self.drone.get_state(olympe.messages.common.SettingsState.ProductSerialHighChanged)['high']) + str(self.drone.get_state(olympe.messages.common.SettingsState.ProductSerialLowChanged)['low'])) # 
		drone_version = self.drone.get_state(olympe.messages.common.SettingsState.ProductVersionChanged) # https://developer.parrot.com/docs/olympe/arsdkng_common_settings.html#olympe.messages.common.SettingsState.ProductVersionChanged
		rospy.logdebug('Drone version: software: %s, hardware: %s', drone_version['software'], drone_version['hardware'])
		flights_status = self.drone.get_state(olympe.messages.ardrone3.SettingsState.MotorFlightsStatusChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_settings_state.html#olympe.messages.ardrone3.SettingsState.MotorErrorStateChanged
		rospy.loginfo('Number of flights: %i', flights_status['nbFlights'])
		rospy.loginfo('Total flight duration: %s', str(datetime.timedelta(seconds=flights_status['totalFlightDuration'])))
		rospy.logdebug('Battery serial: %s', self.drone.get_state(olympe.messages.battery.serial)['serial']) # https://developer.parrot.com/docs/olympe/arsdkng_battery.html#olympe.messages.battery.serial
		rospy.loginfo('Battery cycle count: %i', self.drone.get_state(olympe.messages.battery.cycle_count)['count']) # https://developer.parrot.com/docs/olympe/arsdkng_battery.html#olympe.messages.battery.cycle_count
		rospy.loginfo('Battery health: %i%%', self.drone.get_state(olympe.messages.battery.health)['state_of_health']) # https://developer.parrot.com/docs/olympe/arsdkng_battery.html#olympe.messages.battery.health
		rospy.logdebug('Camera states: ' + str(self.drone.get_state(olympe.messages.camera.camera_states))) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.camera_states
		rospy.logdebug('Camera capabilities: ' + str(self.drone.get_state(olympe.messages.camera.camera_capabilities))) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.camera_capabilities	
		rospy.logdebug('Recording capabilities: ' + str(self.drone.get_state(olympe.messages.camera.recording_capabilities))) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.recording_capabilities
				
		max_tilt = self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.MaxTiltChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.MaxTiltChanged
		rospy.logdebug('MaxTilt = %f [%f, %f]', max_tilt["current"], max_tilt["min"], max_tilt["max"])
		max_vertical_speed = self.drone.get_state(olympe.messages.ardrone3.SpeedSettingsState.MaxVerticalSpeedChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettingsState.MaxVerticalSpeedChanged
		rospy.logdebug('MaxVerticalSpeed = %f [%f, %f]', max_vertical_speed["current"], max_vertical_speed["min"], max_vertical_speed["max"])
		max_rotation_speed = self.drone.get_state(olympe.messages.ardrone3.SpeedSettingsState.MaxRotationSpeedChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettingsState.MaxRotationSpeedChanged
		rospy.logdebug('MaxRotationSpeed = %f [%f, %f]', max_rotation_speed["current"], max_rotation_speed["min"], max_rotation_speed["max"])
		max_pitch_roll_rotation_speed = self.drone.get_state(olympe.messages.ardrone3.SpeedSettingsState.MaxPitchRollRotationSpeedChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettingsState.MaxPitchRollRotationSpeedChanged
		rospy.logdebug('MaxPitchRollRotationSpeed = %f [%f, %f]', max_pitch_roll_rotation_speed["current"], max_pitch_roll_rotation_speed["min"], max_pitch_roll_rotation_speed["max"])
		max_distance = self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.MaxDistanceChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.MaxDistanceChanged
		rospy.logdebug('MaxDistance = %f [%f, %f]', max_distance["current"], max_distance["min"], max_distance["max"])
		max_altitude = self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.MaxAltitudeChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.MaxAltitudeChanged
		rospy.logdebug('MaxAltitude = %f [%f, %f]', max_altitude["current"], max_altitude["min"], max_altitude["max"])
		rospy.logdebug('NoFlyOverMaxDistance = %i', self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.NoFlyOverMaxDistanceChanged)["shouldNotFlyOver"]) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.NoFlyOverMaxDistanceChanged
		rospy.logdebug('BankedTurn = %i', self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.BankedTurnChanged)["state"]) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.BankedTurnChanged
		absolute_attitude_bounds = self.drone.get_state(olympe.messages.gimbal.absolute_attitude_bounds)[0] # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.absolute_attitude_bounds
		rospy.logdebug('GimbalAbsoluteBounds (deg): roll=[%f, %f], pitch=[%f, %f], yaw=[%f, %f]', absolute_attitude_bounds["min_roll"], absolute_attitude_bounds["max_roll"], absolute_attitude_bounds["min_pitch"], absolute_attitude_bounds["max_pitch"], absolute_attitude_bounds["min_yaw"], absolute_attitude_bounds["max_yaw"])
		relative_attitude_bounds = self.drone.get_state(olympe.messages.gimbal.relative_attitude_bounds)[0] # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.relative_attitude_bounds
		rospy.logdebug('GimbalRelativeBounds (deg): roll=[%f, %f], pitch=[%f, %f], yaw=[%f, %f]', relative_attitude_bounds["min_roll"], relative_attitude_bounds["max_roll"], relative_attitude_bounds["min_pitch"], relative_attitude_bounds["max_pitch"], relative_attitude_bounds["min_yaw"], relative_attitude_bounds["max_yaw"])
		max_speed = self.drone.get_state(olympe.messages.gimbal.max_speed)[0] # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.max_speed
		rospy.logdebug('GimbalMaxSpeed (deg/s): roll=%f [%f, %f], pitch=%f [%f, %f], yaw=%f [%f, %f]', max_speed["current_roll"], max_speed["min_bound_roll"], max_speed["max_bound_roll"], max_speed["current_pitch"], max_speed["min_bound_pitch"], max_speed["max_bound_pitch"], max_speed["current_yaw"], max_speed["min_bound_yaw"], max_speed["max_bound_yaw"])
		
		if self.skycontroller_enabled:
			skyctrl_version = self.drone.get_state(olympe.messages.skyctrl.SettingsState.ProductVersionChanged) # https://developer.parrot.com/docs/olympe/arsdkng_skyctrl_settings.html#olympe.messages.skyctrl.SettingsState.ProductVersionChanged
			rospy.logdebug('Controller version: software=%s, hardware=%s', skyctrl_version['software'], skyctrl_version['hardware'])
			rospy.logdebug('Validity from drone: %r ', self.drone.get_state(validity_from_drone)["is_valid"] == 1) # https://developer.parrot.com/docs/olympe/arsdkng_controller_info.html#olympe.messages.controller_info.validity_from_drone
		
		mediastore_state = self.drone.get_state(mediastore_state_message)['state'] # https://developer.parrot.com/docs/olympe/arsdkng_mediastore.html#olympe.messages.mediastore.state
		if mediastore_state == mediastore_state_enum.not_available:
			rospy.logerr('Mediastore state is not available')
		else:
			if mediastore_state == mediastore_state_enum.indexing:
				rospy.logwarn('Mediastore state is indexig')
			else:
				rospy.loginfo('Mediastore state is indexed')
				
		#if self.model in {"thermal", "usa"}:
		#	rospy.logwarn('thermal_capabilities: ' + str(self.drone.get_state(olympe.messages.thermal.capabilities)))
		#	rospy.logwarn('emissivity: ' + str(self.drone.get_state(olympe.messages.thermal.emissivity)))
		#	self.drone(olympe.messages.thermal.set_mode(mode="blended")).wait() # https://developer.parrot.com/docs/olympe/arsdkng_thermal.html#olympe.messages.thermal.set_mode
		#	rospy.logwarn('thermal_mode: ' + str(self.drone.get_state(olympe.messages.thermal.mode)))
		#	self.drone(olympe.messages.thermal.set_rendering(mode="blended", blending_rate=0.5)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_thermal.html#olympe.messages.thermal.set_rendering
		#	rospy.logwarn('rendering: ' + str(self.drone.get_state(olympe.messages.thermal.rendering)))
		#	rospy.logwarn('sensitivity: ' + str(self.drone.get_state(olympe.messages.thermal.sensitivity)))
										
	def connect(self):
		self.msg_skycontroller = SkycontrollerCommand()
		self.msg_skycontroller.header.frame_id = 'body'

		self.running = False

		rate = rospy.Rate(1) # 1hz
		while True:
			self.pub_state.publish("CONNECTING")
			if self.drone_serial != "":
				rospy.loginfo_once("Connecting to %s with %s", self.drone_serial, self.wifi_key)
				self.drone(olympe.messages.drone_manager.connect(  # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.connect
					serial=self.drone_serial,
					key=self.wifi_key
				)).wait()  # TODO: check why sometimes doesn't connect
				if self.drone(connection_state(state="connected", _policy="check")):  # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.enums.drone_manager.connection_state
					break
			else:
				if self.drone.connect():
					break
			if rospy.is_shutdown():
				exit()
			rate.sleep()

		if self.skycontroller_enabled: # connect to the SkyController
			self.pub_state.publish("CONNECTED_SKYCONTROLLER")
			rospy.loginfo("Connected to SkyController")
			self.switch_manual()
					
			while True: # connect to the drone
				if self.drone(connection_state(state="connected", _policy="check")):
					break				
				if rospy.is_shutdown():
					exit()
				else:
					self.pub_state.publish("SERCHING_DRONE")
					rospy.loginfo_once("Connection to Anafi: " + self.drone.get_state(connection_state)["state"].name)
				rate.sleep()
			self.pub_state.publish("CONNECTED_DRONE")			
			rospy.loginfo("Connection to Anafi: " + self.drone.get_state(connection_state)["state"].name)
		else: # connect to the Anafi
			self.pub_state.publish("CONNECTED_DRONE")
			rospy.loginfo("Connected to Anafi")
			self.switch_offboard()
			
		rospy.logdebug('Boot Id: ' + self.drone.get_state(olympe.messages.common.CommonState.BootId)['bootId']) # https://developer.parrot.com/docs/olympe/arsdkng_common_common.html#olympe.messages.common.CommonState.BootId

		self.running = True

		self.event_listener_anafi.subscribe()
		self.event_listener_skycontroller.subscribe()

		self.fast_timer = rospy.Timer(rospy.Duration(0.01), self.fast_callback)
		self.slow_timer = rospy.Timer(rospy.Duration(1.00), self.slow_callback)

		self.frame_queue = queue.Queue(maxsize=1)  # TODO: replace by a shared variable
		self.processing_thread = threading.Thread(target=self.yuv_frame_processing)

		# Setup the callback functions to do some live video processing
		self.drone.streaming.set_callbacks(
			raw_cb=self.yuv_frame_cb,
			flush_raw_cb=self.flush_cb)
		self.drone.streaming.start()
		self.processing_thread.start()
		
	def disconnect(self):
		self.pub_state.publish("DISCONNECTING")
		self.msg_skycontroller = SkycontrollerCommand()
		self.msg_skycontroller.header.stamp = rospy.Time.now()
		self.pub_skyctrl_command.publish(self.msg_skycontroller)

		if self.running:  # disconnecting before started publishing anything
			self.running = False
			self.event_listener_anafi.unsubscribe()
			self.event_listener_skycontroller.unsubscribe()
			self.fast_timer.shutdown()
			self.slow_timer.shutdown()
			self.processing_thread.join()
			self.drone.streaming.stop()

		self.drone.disconnect()
		self.pub_state.publish("DISCONNECTED")
		
	def stop(self):
		rospy.loginfo("Anafi_bridge is stopping...")
		self.disconnect()
						
	def reconfigure_callback(self, config, level):
		if level == -1 or level == 1:  # piloting related
			self.drone(MaxTilt(config['max_tilt']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html?#olympe.messages.ardrone3.PilotingSettings.MaxTilt
			self.drone(MaxVerticalSpeed(config['max_vertical_speed']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettings.MaxVerticalSpeed
			self.drone(MaxRotationSpeed(config['max_yaw_rotation_speed']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettings.MaxRotationSpeed
			self.drone(MaxPitchRollRotationSpeed(config['max_pitch_roll_rotation_speed']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettings.MaxPitchRollRotationSpeed
			self.drone(MaxDistance(config['max_distance']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.MaxDistance
			self.drone(MaxAltitude(config['max_altitude']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.MaxAltitude
			self.drone(BankedTurn(int(config['banked_turn'])))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.BankedTurn
			self.drone(set_style(style=style(int(config['camera_operated']))))  # https://developer.parrot.com/docs/olympe/arsdkng_piloting_style.html#olympe.messages.piloting_style.set_style
			self.max_tilt = config['max_tilt']
			self.max_horizontal_speed = config['max_horizontal_speed']
			self.max_vertical_speed = config['max_vertical_speed']
			self.max_rotation_speed = config['max_yaw_rotation_speed']
		if level == -1 or level == 2:  # RTH related
			self.drone(olympe.messages.rth.set_preferred_home_type(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_preferred_home_type
				type=olympe.enums.rth.home_type(int(config['home_type']))))  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.enums.rth.home_type
			self.drone(set_ending_behavior(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_ending_behavior
				ending_behavior='landing' if config['ending_behavior'] == 0 else 'hovering'))  # {'landing', 'hovering'}
			self.drone(set_ending_hovering_altitude(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_ending_hovering_altitude
				altitude=config['hovering_altitude']))  # AGL altitude (m)
			self.drone(set_min_altitude(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_min_altitude
				altitude=config['min_altitude']))  # ATO altitude (m)
			self.drone(olympe.messages.rth.set_auto_trigger_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_auto_trigger_mode
				mode=olympe.enums.rth.auto_trigger_mode(int(config['auto_trigger']))))  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.enums.rth.auto_trigger_mode
			self.drone(precise_home_set_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_precise_home.html#olympe.messages.precise_home.set_mode
				mode=precise_home_mode(int(config['precise_home']))))  # https://developer.parrot.com/docs/olympe/arsdkng_precise_home.html#olympe.enums.precise_home.mode
		if level == -1 or level == 3: # camera related	
			self.camera_mode = config['camera_mode']
			self.drone(camera.set_camera_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_camera_mode
				cam_id=0,
				value=olympe.enums.camera.camera_mode(self.camera_mode)))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.camera_mode
			self.drone(camera.set_ev_compensation(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_ev_compensation
				cam_id=0,
				value=olympe.enums.camera.ev_compensation(config['ev_compensation'])))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.ev_compensation
			self.drone(camera.set_hdr_setting(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_hdr_setting
				cam_id=0,
				value=availability.available if config['hdr'] else availability.not_available))  # CHECK for a potencial bug
			self.drone(camera.set_max_zoom_speed(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_max_zoom_speed
				cam_id=0,
				max=config['max_zoom_speed']))  # [0.01, 10] (tan(deg)/sec)
			self.drone(camera.set_streaming_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_streaming_mode
				cam_id=0,
				value=olympe.enums.camera.streaming_mode(config['streaming_mode'])))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.streaming_mode
			self.drone(camera.set_style(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_style
				cam_id=0,
				style=olympe.enums.camera.style(config['image_style'])))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.style
		if level == -1 or level == 4:  # photo related
			self.drone(camera.set_photo_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_photo_mode
				cam_id=0,
				mode=olympe.enums.camera.photo_mode(config['photo_mode']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.photo_mode
				format=olympe.enums.camera.photo_format(config['photo_format']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.photo_format
				file_format=olympe.enums.camera.photo_file_format(config['file_format']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.photo_file_format
				burst=olympe.enums.camera.burst_value.burst_14_over_1s,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.photo_file_format
				bracketing=olympe.enums.camera.bracketing_preset.preset_1ev_2ev_3ev,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.bracketing_preset
				capture_interval=1))  # (s\time_lapse, m\gps_lapse)
		if level == -1 or level == 5:  # video related
			self.drone(camera.set_autorecord(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_autorecord
				cam_id=0,
				state="active" if config['autorecord'] else "inactive"))
			if config['recording_mode'] == 0 or config['recording_mode'] == 1:  # standard OR hyperlapse
				self.drone(camera.set_recording_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_recording_mode
					cam_id=0,
					mode=olympe.enums.camera.recording_mode(config['recording_mode']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.recording_mode
					resolution=olympe.enums.camera.resolution.res_1080p,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.resolution
					framerate=olympe.enums.camera.framerate.fps_30,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.framerate
					hyperlapse=olympe.enums.camera.hyperlapse_value.ratio_15))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.hyperlapse
			if config['recording_mode'] == 2 or config['recording_mode'] == 3:  # slow_motion OR high_framerate
				self.drone(camera.set_recording_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_recording_mode
					cam_id=0,
					mode=olympe.enums.camera.recording_mode(config['recording_mode']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.recording_modeoffboard
					resolution=olympe.enums.camera.resolution.res_720p,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.resolution
					framerate=olympe.enums.camera.framerate.fps_120,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.framerate
					hyperlapse=olympe.enums.camera.hyperlapse_value(0)))  # not used
			if config['recording_mode'] == 4:  # high_resolution
				self.drone(camera.set_recording_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_recording_mode
					cam_id=0,
					mode=olympe.enums.camera.recording_mode.standard,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.recording_mode
					resolution=olympe.enums.camera.resolution.res_dci_4k,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.resolution
					framerate=olympe.enums.camera.framerate.fps_24,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.framerate
					hyperlapse=olympe.enums.camera.hyperlapse_value(0)))  # not used
		if level == -1 or level == 6:  # media download related
			self.download_folder = config['download_folder']
			self.cut_media = config['cut_media']
		if level == -1 or level == 7:  # gimbal related
			self.gimbal_frame = 'absolute' if config['gimbal_absolute'] else 'relative'
			self.drone(gimbal.set_max_speed(  # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.max_speed
				gimbal_id=0,
				yaw=0, 
				pitch=config['max_gimbal_speed'],  # [1, 180] (deg/s)
				roll=config['max_gimbal_speed']))  # [1, 180] (deg/s)
			self.max_gimbal_speed = config['max_gimbal_speed']	
		return config
		
	def yuv_frame_cb(self, yuv_frame):  # this function will be called by Olympe for each decoded YUV frame
		yuv_frame.ref()
		if self.frame_queue.full():
			self.frame_queue.get_nowait().unref()
		self.frame_queue.put_nowait(yuv_frame)

	def flush_cb(self, stream):
		if stream["vdef_format"] != olympe.VDEF_I420:
			return True
		while not self.frame_queue.empty():
			self.frame_queue.get_nowait().unref()
		return True

	def yuv_frame_processing(self):
		while self.running:
			try:
				yuv_frame = self.frame_queue.get(timeout=0.1)
			except queue.Empty:
				continue

			info = yuv_frame.info()  # the VideoFrame.info() dictionary contains some useful information such as the video resolution
			rospy.logdebug_throttle(10, "yuv_frame.info = " + str(info))

			vmeta = yuv_frame.vmeta()  # yuv_frame.vmeta() returns a dictionary that contains additional metadata from the drone
			rospy.logdebug_throttle(10, "yuv_frame.vmeta = " + str(vmeta))

			if vmeta[1] != {}:
				self.header.stamp = rospy.Time.now()
				
				frame_timestamp = info['raw']['frame']['timestamp']  # timestamp (millisec)
				self.msg_time.data = frame_timestamp  # TODO: check correctness -> secs = int(frame_timestamp//1e6), nsecs = int(frame_timestamp%1e6*1e3)
				self.pub_time.publish(self.msg_time)

				drone_quat = vmeta[1]['drone']['quat']  # attitude
				self.msg_attitude.header = self.header
				self.msg_attitude.header.frame_id = '/world'
				self.msg_attitude.quaternion = Quaternion(drone_quat['x'], -drone_quat['y'], -drone_quat['z'], drone_quat['w'])
				self.pub_attitude.publish(self.msg_attitude)

				quaternion = [drone_quat['x'], -drone_quat['y'], -drone_quat['z'], drone_quat['w']]
				(roll, pitch, yaw) = euler_from_quaternion(quaternion)
				self.msg_rpy.header = self.header
				self.msg_rpy.header.frame_id = '/world'
				self.msg_rpy.vector.x = roll*180/math.pi
				self.msg_rpy.vector.y = pitch*180/math.pi
				self.msg_rpy.vector.z = yaw*180/math.pi
				self.pub_rpy.publish(self.msg_rpy)

				ground_distance = vmeta[1]['drone']['ground_distance']  # barometer (m)
				self.pub_altitude.publish(ground_distance)

				speed = vmeta[1]['drone']['speed']  # opticalflow speed (m/s)
				self.msg_speed.header = self.header
				self.msg_speed.header.frame_id = '/world'
				self.msg_speed.vector.x = speed['north']
				self.msg_speed.vector.y = -speed['east']
				self.msg_speed.vector.z = -speed['down']
				self.pub_speed.publish(self.msg_speed)

				battery_percentage = vmeta[1]['drone']['battery_percentage']  # [0=empty, 100=full]
				self.pub_battery.publish(battery_percentage)
				if battery_percentage%10 == 0:
					rospy.loginfo_throttle(100, "Battery level: " + str(battery_percentage) + "%")

				camera_quat = vmeta[1]['camera']['quat']
				self.msg_attitude.header.frame_id = '/body'
				self.msg_attitude.quaternion = Quaternion(camera_quat['x'], -camera_quat['y'], -camera_quat['z'], camera_quat['w'])
				self.pub_camera_attitude.publish(self.msg_attitude)

				camera_base_quat = vmeta[1]['camera']['base_quat']
				self.msg_attitude.header.frame_id = '/body'
				self.msg_attitude.quaternion = Quaternion(camera_base_quat['x'], -camera_base_quat['y'], -camera_base_quat['z'], camera_base_quat['w'])
				self.pub_camera_base_attitude.publish(self.msg_attitude)

				exposure_time = vmeta[1]['camera']['exposure_time']
				self.pub_exposure_time.publish(exposure_time)

				iso_gain = vmeta[1]['camera']['iso_gain']
				self.pub_iso_gain.publish(iso_gain)

				awb_r_gain = vmeta[1]['camera']['awb_r_gain']
				self.pub_awb_r_gain.publish(awb_r_gain)

				awb_b_gain = vmeta[1]['camera']['awb_b_gain']
				self.pub_awb_b_gain.publish(awb_b_gain)

				hfov = vmeta[1]['camera']['hfov']
				self.pub_hfov.publish(hfov)

				vfov = vmeta[1]['camera']['vfov']
				self.pub_vfov.publish(vfov)

				self.state = vmeta[1]['drone']['flying_state']  # ['LANDED', 'MOTOR_RAMPING', 'USER_TAKEOFF', 'TAKINGOFF', 'HOVERING', 'FLYING', 'LANDING', 'EMERGENCY']
				self.pub_state.publish(self.state)

				goodput = vmeta[1]['links'][0]['wifi']['goodput']  # throughput of the connection (b/s)
				self.pub_link_goodput.publish(goodput)

				quality = vmeta[1]['links'][0]['wifi']['quality']  # [0=bad, 5=good]
				self.pub_link_quality.publish(quality)

				rssi = vmeta[1]['links'][0]['wifi']['rssi']  # signal strength [-100=bad, 0=good] (dBm)
				self.pub_wifi_rssi.publish(rssi)

				# log signal strength
				if rssi <= -60:
					if rssi >= -70:
						rospy.loginfo_throttle(100, "Signal strength: " + str(rssi) + "dBm")
					else:
						if rssi >= -80:
							rospy.logwarn_throttle(10, "Weak signal: " + str(rssi) + "dBm")
						else:
							if rssi >= -90:
								rospy.logerr_throttle(1, "Unreliable signal:" + str(rssi) + "dBm")
							else:
								rospy.logfatal_throttle(0.1, "Unusable signal: " + str(rssi) + "dBm")

				cv2_cvt_color_flag = {  # convert pdraw YUV flag to OpenCV YUV flag
					olympe.VDEF_I420: cv2.COLOR_YUV2BGR_I420,
					olympe.VDEF_NV12: cv2.COLOR_YUV2BGR_NV12,
				}[yuv_frame.format()]
				cv2frame = cv2.cvtColor(yuv_frame.as_ndarray(), cv2_cvt_color_flag)  # use OpenCV to convert the yuv frame to RGB

				msg_image = self.bridge.cv2_to_imgmsg(cv2frame, "bgr8")
				timestamp = info['ntp_raw_unskewed_timestamp']  # image capture timestamp (ms)
				msg_image.header.stamp.secs = int(timestamp//1e6)
				msg_image.header.stamp.nsecs = int((timestamp%1e6)*1e3)
				self.pub_image.publish(msg_image)

				self.msg_camera_info.header = self.header
				self.msg_camera_info.header.frame_id = '/camera'
				self.pub_camera_info.publish(self.msg_camera_info)
			else:
				rospy.logwarn("Frame lost!")

			yuv_frame.unref()

	def discover_drones(self, request):
		rospy.loginfo("Discovering drones...")
		self.drone(olympe.messages.drone_manager.discover_drones()).wait() # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.discover_drones
		drone_list = self.drone.get_state(olympe.messages.drone_manager.drone_list_item) # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.drone_list_item
		for drone in drone_list:
			rospy.loginfo("Drone: serial=%s, model=%i, name=%s, connection order=%s, connecting=%s, visible=%s, security=%s, saved key=%s, rssi=%i",
						  drone_list[drone]['serial'], drone_list[drone]['model'], drone_list[drone]['name'],
						  (drone_list[drone]['connection_order'] if drone_list[drone]['connection_order'] > 0 else 'never connected'),
						  ('yes' if drone_list[drone]['active'] == 1 else 'no'),
						  ('yes' if drone_list[drone]['visible'] == 1 else 'no'), drone_list[drone]['security'].name,
						  ('yes' if drone_list[drone]['has_saved_key'] == 1 else 'no'), drone_list[drone]['rssi'])
		return []
		
	def forget_drone(self, request):
		rospy.loginfo("Forgetting drone " + request.data)
		self.drone(olympe.messages.drone_manager.forget(serial=request.data)).wait().success()  # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.forget
		return []

	def takeoff(self, request):
		rospy.logwarn("Taking off")
		assert self.drone(TakeOff()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.TakeOff
		run_id = self.drone.get_state(olympe.messages.common.RunState.RunIdChanged) # https://developer.parrot.com/docs/olympe/arsdkng_common_runstate.html#olympe.messages.common.RunState.RunIdChanged
		rospy.logdebug('Run Id: ', run_id['runId'])
		return []
	
	def arm(self, request):
		if request.data:
			rospy.logwarn("Arming")
			assert self.drone(UserTakeOff(state = 1)).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.UserTakeOff
		else:
			rospy.loginfo("Disarming")
			assert self.drone(Emergency() >> FlyingStateChanged(state="landed")).wait().success() # the fastest way to disarm
		return []

	def land(self, request):		
		rospy.loginfo("Landing")
		assert self.drone(Landing()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.Landing
		flights_status = self.drone.get_state(olympe.messages.ardrone3.SettingsState.MotorFlightsStatusChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_settings_state.html#olympe.messages.ardrone3.SettingsState.MotorErrorStateChanged
		rospy.loginfo('Flight duration = %is', flights_status['lastFlightDuration'])
		return []
		
	def emergency(self, request):		
		assert self.drone(Emergency()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.Emergency
		
		if self.drone.get_state(olympe.messages.ardrone3.SoundState.AlertSound)["state"] == olympe.enums.ardrone3.SoundState.AlertSound_State.stopped: # DEPRECATED: https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_sound.html#olympe.messages.ardrone3.SoundState.AlertSound
			rospy.logfatal("Emergency!!!")
			self.drone(olympe.messages.ardrone3.Sound.StartAlertSound()) # DEPRECATED: https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_sound.html#olympe.messages.ardrone3.Sound.StartAlertSound
		else:
			self.drone(olympe.messages.ardrone3.Sound.StopAlertSound()) # DEPRECATED: https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_sound.html#olympe.messages.ardrone3.Sound.StopAlertSound
		return []
		
	def halt(self, request):  # calls all commands to halt
		rospy.logwarn("HALT!!!")
		self.drone(PCMD(flag=1, roll=0, pitch=0, yaw=0, gaz=0, timestampAndSeqNum=0))
		self.drone(NavigateHome(start=0))
		self.drone(StopPilotedPOI())
		self.drone(olympe.messages.common.Mavlink.Stop())
		self.drone(olympe.messages.follow_me.stop())
		self.drone(olympe.messages.rth.abort())
		return []
		
	def navigate_home(self, request):
		if request.data: 	
			rospy.loginfo("Navigating Home")
			assert self.drone(PCMD(flag=1, roll=0, pitch=0, yaw=0, gaz=0, timestampAndSeqNum=0)).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.PCMD
			assert self.drone(NavigateHome(start=1)).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.NavigateHome
		else:
			rospy.loginfo("Stopping Navigation Home")		
			assert self.drone(NavigateHome(start=0)).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.NavigateHome
		navigate_home_state = self.drone.get_state(olympe.messages.ardrone3.PilotingState.NavigateHomeStateChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingState.NavigateHomeStateChanged
		rospy.loginfo("Navigate Home State: state = %s, reason = %s",
					  navigate_home_state['state'].name, navigate_home_state['reason'].name)
		return []
		
	def rth(self, request):		
		rospy.loginfo("Returning to Home")
		assert self.drone(return_to_home()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.return_to_home
		return []
		
	def set_home(self, request):		
		rospy.loginfo("Setting Home")
		assert self.drone(olympe.messages.rth.set_custom_location( # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.return_to_home
			latitude=request.latitude, # latitude of the takeoff location
			longitude=request.longitude, # longitude of the takeoff location
			altitude=request.altitude # altitude of the custom location above takeoff (ATO).		
			)).wait().success() 
		return []
		
	def start_piloted_POI(self, request):
		rospy.loginfo("Starting Piloted Point of Interest")		
		assert self.drone(StartPilotedPOIV2( # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.StartPilotedPOIV2
			latitude=request.latitude, # latitude of the location to look at (deg)
			longitude=request.longitude, # longitude of the location to look at (deg)
			altitude=request.altitude, # altitude above take off point to look at (m)
			mode=('locked_gimbal' if request.locked_gimbal else 'free_gimbal') # gimbal is locked on the POI OR freely controllable
			)).wait().success()
		piloted_poi_state = self.drone.get_state(olympe.messages.ardrone3.PilotingState.PilotedPOIV2) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingState.PilotedPOIV2
		rospy.loginfo("Piloted POI State: latitude = %f, longitude = %f, altitude = %f, mode = %s, status = %s",
					  piloted_poi_state['latitude'], piloted_poi_state['longitude'], piloted_poi_state['altitude'],
					  piloted_poi_state['mode'].name, piloted_poi_state['status'].name)
		return []
	
	def stop_piloted_POI(self, request):
		rospy.loginfo("Stopping Piloted Point of Interest")		
		assert self.drone(StopPilotedPOI()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.StopPilotedPOI
		return []
			
	def flightplan_upload(self, request): # https://forum.developer.parrot.com/t/olympe-mavlink-working-example/14041/2	
		rospy.loginfo("FlightPlan uploading from " + request.filepath)
		rospy.loginfo("REST API: PUT http://" + self.ip + ":180/api/v" + self.rest_api_version + "/upload/flightplan,  data=" + request.filepath)
		response = requestuests.put(url="http://" + self.ip + ":180/api/v" + self.rest_api_version + "/upload/flightplan", data=open(request.filepath, "rb"))
		response.raise_for_status()
		self.uid = response.json()
		rospy.loginfo("FlightPlan uploaded with UID " + self.uid)
		return []	
		
	def flightplan_start(self, request): # https://forum.developer.parrot.com/t/olympe-mavlink-working-example/14041/2
		uid = (request.uid if request.uid != "" else self.uid)
		rospy.logwarn("FlightPlan starting with UID " + uid)
		rospy.logdebug("REST API: GET http://" + self.ip + ":180/api/v" + self.rest_api_version + "/upload/flightplan/" + uid)
		response = requestuests.get("http://" + self.ip + ":180/api/v" + self.rest_api_version + "/upload/flightplan/" + uid)
		response.raise_for_status()
		if response.status_code == requestuests.codes.ok:
			self.drone(
				olympe.messages.common.Mavlink.Start( # https://developer.parrot.com/docs/olympe/arsdkng_common_mavlink.html#olympe.messages.common.Mavlink.Start
				filepath=uid, # TODO: check why sometimes doesn't take the filepath
				type='flightPlan' # https://developer.parrot.com/docs/olympe/arsdkng_common_mavlink.html#olympe.enums.common.Mavlink.Start_Type
				)).wait()
				
			if self.drone.get_state(olympe.messages.common.FlightPlanState.AvailabilityStateChanged)['AvailabilityState'] == 0: # https://developer.parrot.com/docs/olympe/arsdkng_common_flightplan.html#olympe.messages.common.FlightPlanState.AvailabilityStateChanged
				components = self.drone.get_state(olympe.messages.common.FlightPlanState.ComponentStateListChanged) # https://developer.parrot.com/docs/olympe/arsdkng_common_flightplan.html#olympe.messages.common.FlightPlanState.ComponentStateListChanged
				for component in components:
					if components[component]['State'] == 0:
						rospy.logwarn("FlightPlan: %s is NOT OK", str(components[component]['component'].name))
					else:
						rospy.loginfo("FlightPlan: %s is OK", str(components[component]['component'].name))
		else:
			rospy.logwarn("UID " + uid + " does not exist onboard")
		return []
		
	def flightplan_pause(self, request):
		rospy.loginfo("FlightPlan pausing")
		assert self.drone(olympe.messages.common.Mavlink.Pause()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_common_mavlink.html#olympe.messages.common.Mavlink.Pause
		return []
		
	def flightplan_stop(self, request):
		rospy.loginfo("FlightPlan stopping")
		assert self.drone(olympe.messages.common.Mavlink.Stop()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_common_mavlink.html#olympe.messages.common.Mavlink.Stop
		return []
		
	def followme_start(self, request):
		rospy.logwarn("FollowMe starting with " + olympe.enums.follow_me.mode(request.mode).name)
		rospy.loginfo("Target is controller: %r", self.drone.get_state(olympe.messages.follow_me.target_is_controller)['state'] == 1) # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.target_is_controller
		self.drone(olympe.messages.follow_me.target_framing_position( # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.target_framing_position
			horizontal=request.horizontal,
			vertical=request.vertical
			)).wait()
		self.drone(olympe.messages.follow_me.target_image_detection( # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.target_image_detection
			target_azimuth=request.target_azimuth,
			target_elevation=request.target_elevation,
			change_of_scale=request.change_of_scale,
			confidence_index=request.confidence_index,
			is_new_selection=request.is_new_selection
			)).wait()
		self.drone(olympe.messages.follow_me.start( # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.start
			mode=olympe.enums.follow_me.mode(request.mode) # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.enums.follow_me.mode
			)).wait()
		return []
			
	def followme_stop(self, request):
		rospy.loginfo("FollowMe stopping")
		assert self.drone(olympe.messages.follow_me.stop()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.stop
		return []
		
	def offboard(self, request):
		if request.data:	
			self.switch_offboard()
		else:
			self.switch_manual()
		return []
	
	def calibrate_magnetometer(self, request):
		if self.drone.get_state(olympe.messages.common.CalibrationState.MagnetoCalibrationrequestuiredState)['requestuired'] == 1: # https://developer.parrot.com/docs/olympe/arsdkng_common_calibration.html#olympe.messages.common.CalibrationState.MagnetoCalibrationrequestuiredState
			rospy.logwarn("Magnetometer calibration started")
			self.drone(olympe.messages.common.Calibration.MagnetoCalibration(calibrate=1)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_common_calibration.html#olympe.messages.common.Calibration.MagnetoCalibration
			calibrating_axis = -1
			while True:
				calibration_axis = self.drone.get_state(olympe.messages.common.CalibrationState.MagnetoCalibrationAxisToCalibrateChanged)['axis']
				if calibration_axis is olympe.enums.common.CalibrationState.MagnetoCalibrationAxisToCalibrateChanged_Axis.none:
					break
				if calibrating_axis != calibration_axis.value:
					rospy.logwarn("Rotate the drone around " + calibration_axis.name)
					calibrating_axis = calibration_axis.value				
				rospy.sleep(1)
			state = self.drone.get_state(olympe.messages.common.CalibrationState.MagnetoCalibrationStateChanged) # https://developer.parrot.com/docs/olympe/arsdkng_common_calibration.html#olympe.messages.common.CalibrationState.MagnetoCalibrationStateChanged
			if state['calibrationFailed'] == 1:
				rospy.logfatal("Calibration failed")
			if state['xAxisCalibration'] == 1 and state['yAxisCalibration'] == 1 and state['zAxisCalibration'] == 1:
				rospy.loginfo("Calibration completed")
			else:
				rospy.logwarn("Calibration status: x-axis - %s, y-axis - %s, z-axis - %s",
							  ('completed' if state['xAxisCalibration'] else 'failed'),
							  ('completed' if state['yAxisCalibration'] else 'failed'),
							  ('completed' if state['zAxisCalibration'] else 'failed'))
		else:
			rospy.loginfo("Magnetometer calibration is not requestuired")
		return []
		
	def calibrate_gimbal(self, request):
		if self.drone.get_state(olympe.messages.gimbal.calibration_state)[0]['state'] == olympe.enums.gimbal.calibration_state.requestuired: # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.calibration_state
			rospy.loginfo("Calibrating gimbal")
			self.drone(olympe.messages.gimbal.calibrate(gimbal_id=0)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.calibrate
		else:
			rospy.loginfo("Gimbal calibration is not requestuired")
		return []
		
	def reset_zoom(self, request):        	
		rospy.logdebug("Reseting zoom")
		self.drone(camera.reset_zoom(cam_id=0)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.reset_zoom
		return []
		
	def reset_gimbal(self, request):
		rospy.logdebug("Reseting gimbal")
		self.drone(olympe.messages.gimbal.reset_orientation(gimbal_id=0)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.reset_orientation
		return []
			
	def take_photo(self, request):
		rospy.loginfo("Taking photo")
		self.drone(camera.set_camera_mode(cam_id=0, value="photo")).wait()
		self.drone(camera.take_photo(cam_id=0)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.take_photo
		self.drone(camera.set_camera_mode(cam_id=0, value="recording" if self.camera_mode == 0 else "photo"))
		return []
		
	def stop_photo(self, request):
		rospy.loginfo("Stopping photo")
		self.drone(camera.stop_photo(cam_id=0)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.stop_photo
		self.drone(camera.set_camera_mode(cam_id=0, value="recording" if self.camera_mode == 0 else "photo"))
		return []
		
	def start_recording(self, request):
		rospy.loginfo("Starting recording")
		self.drone(camera.set_camera_mode(cam_id=0, value="recording")).wait() # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_camera_mode
		self.drone(camera.start_recording(cam_id=0)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.start_recording
		return []
		
	def stop_recording(self, request):
		rospy.loginfo("Stopping recording")
		self.drone(camera.stop_recording(cam_id=0)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.stop_recording
		self.drone(camera.set_camera_mode(cam_id=0, value="recording" if self.camera_mode == 0 else "photo"))
		return []
		
	def download_media(self, request):
		if self.drone.media(indexing_state(state="indexed")).wait(_timeout=10).success():  # FIXME: fails on some drones
			media_id = olympe.Media.list_media(self.drone.media)
			num_media = len(media_id)

			if num_media > 0:
				if not os.path.exists(self.download_folder):  # check if folder exists
					os.mkdir(self.download_folder)
					rospy.loginfo("Folder '%s' created", self.download_folder)
				self.drone.media.download_dir = self.download_folder  # download the photos associated with this media id

				rospy.loginfo("Downloading %i media", num_media)

				media_count = 1
				for media in media_id:
					media_info = olympe.Media.media_info(self.drone.media, media_id = media)
					rospy.loginfo("Media %i/%i: downloading %.1fMB", media_count, num_media, media_info.size/(2**20))
					media_download = self.drone(download_media(media))
					resources = media_download.as_completed(timeout=100)
					rospy.loginfo("Media %i/%i: downloaded %.1fMB", media_count, num_media, media_info.size/(2**20))

					for resource in resources:
						if not resource.success():
							rospy.logerr("Failed to download %s", str(resource.resource_id))
							continue

					media_count += 1

				if self.cut_media:
					self.drone(delete_all_media())
			else:
				rospy.loginfo("No media found")
		else:
			rospy.logwarn("Media is not indexed :(")
		return []
	
	def reboot(self, request):
		rospy.logwarn("Rebooting...")
		assert self.drone(olympe.messages.common.Common.Reboot()).wait().success()  # https://developer.parrot.com/docs/olympe/arsdkng_common_common.html#olympe.messages.common.Common.Reboot
		return []
		
	def format(self, request):
		info = self.drone.get_state(olympe.messages.user_storage.info)  # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.messages.user_storage.info
		if info['name'] != "":
			rospy.loginfo("Formatting media %s (%.1fGB)", info['name'], info['capacity']/(2**30))
			self.drone(olympe.messages.user_storage.format_with_type(  # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.messages.user_storage.format_with_type
				label="",
				type=olympe.enums.user_storage.formatting_type(0))  # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.enums.user_storage.formatting_type
				>>
				olympe.messages.user_storage.start_monitoring(period=1))  # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.messages.user_storage.start_monitoring
		else:
			rospy.logwarn("There is no media to format")
		return []
				
	def rpyt_callback(self, msg):
		self.drone(PCMD(  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.PCMD
			flag=1,
			roll=int(self.bound_percentage(msg.roll/self.max_tilt*100)),  # roll [-100, 100] (% of max tilt)
			pitch=int(self.bound_percentage(msg.pitch/self.max_tilt*100)),  # pitch [-100, 100] (% of max tilt)
			yaw=int(self.bound_percentage(-msg.yaw/self.max_rotation_speed*100)),  # yaw rate [-100, 100] (% of max yaw rate)
			gaz=int(self.bound_percentage(msg.gaz/self.max_vertical_speed*100)),  # vertical speed [-100, 100] (% of max vertical speed)
			timestampAndSeqNum=0))

	def moveBy_callback(self, msg):		
		assert self.drone(move.extended_move_by( # https://developer.parrot.com/docs/olympe/arsdkng_move.html?#olympe.messages.move.extended_move_by
			d_x=msg.dx, # displacement along the front axis (m)
			d_y=msg.dy, # displacement along the right axis (m)
			d_z=msg.dz, # displacement along the down axis (m)
			d_psi=msg.dyaw, # rotation of heading (rad)
			max_horizontal_speed=self.max_horizontal_speed,
			max_vertical_speed=self.max_vertical_speed,
			max_yaw_rotation_speed=self.max_rotation_speed
			)).wait().success()
	
	def moveTo_callback(self, msg):		
		assert self.drone(move.extended_move_to( # https://developer.parrot.com/docs/olympe/arsdkng_move.html?#olympe.messages.move.extended_move_to
			latitude=msg.latitude, # latitude (degrees)
			longitude=msg.longitude, # longitude (degrees)
			altitude=msg.altitude, # altitude (m)
			orientation_mode='heading_start', # orientation mode {'to_target', 'heading_start', 'heading_during'}
			heading=msg.heading, # heading relative to the North (degrees)
			max_horizontal_speed=self.max_horizontal_speed,
			max_vertical_speed=self.max_vertical_speed,
			max_yaw_rotation_speed=self.max_rotation_speed
			)).wait().success()

	def zoom_callback(self, msg):
		self.drone(camera.set_zoom_target(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_zoom_target
			cam_id=0,
			control_mode='level' if msg.mode == 0 else 'velocity', # {'level', 'velocity'}
			target=msg.zoom)) # (in level mode [1,max_zoom])
		
	def gimbal_callback(self, msg):
		self.drone(gimbal.set_target(  # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.set_target
			gimbal_id=0,
			control_mode='position' if msg.mode == 0 else 'velocity', # {'position', 'velocity'}
			yaw_frame_of_reference='none',
			yaw=0.0,
			pitch_frame_of_reference=self.gimbal_frame,  # {'absolute', 'relative', 'none'}
			pitch=-msg.pitch,  # (in position mode [-135,105])
			roll_frame_of_reference=self.gimbal_frame,  # {'absolute', 'relative', 'none'}
			roll=msg.roll)) # (in position mode [-38,38])

	def switch_manual(self):
		self.msg_skycontroller = SkycontrollerCommand()
		self.msg_skycontroller.header.stamp = rospy.Time.now()
		self.pub_skyctrl_command.publish(self.msg_skycontroller)
		
		# button: 	0 = return home, 1 = takeoff/land, 2 = back left, 3 = back right
		self.drone(mapper.grab(buttons=(0<<0|0<<1|0<<2|1<<3), axes=0)).wait() # bitfields
		self.drone(setPilotingSource(source="SkyController")).wait()
		rospy.logwarn("Control: Manual")
			
	def switch_offboard(self):
		# button: 	0 = return home, 1 = takeoff/land, 2 = back left, 3 = back right
		# axis: 	0 = yaw, 1 = trottle, 2 = roll, 3 = pithch, 4 = camera, 5 = zoom
		self.drone(mapper.grab(buttons=(1<<0|0<<1|1<<2|1<<3), axes=(1<<0|1<<1|1<<2|1<<3|1<<4|1<<5))) # bitfields
		self.drone(setPilotingSource(source="Controller")).wait()
		rospy.logwarn("Control: Offboard")

	def fast_callback(self, event):
		motion_state = self.drone.get_state(olympe.messages.ardrone3.PilotingState.MotionState)['state'] # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingState.MotionState
		self.pub_steady.publish(self.state == "LANDED" and motion_state == olympe.enums.ardrone3.PilotingState.MotionState_State.steady)

		if self.skycontroller_enabled:
			self.msg_skycontroller.header.stamp = rospy.Time.now()
			self.pub_skyctrl_command.publish(self.msg_skycontroller)
			# Reset button pressing message
			self.msg_skycontroller.return_home = False
			self.msg_skycontroller.takeoff_land = False
			self.msg_skycontroller.reset_camera = False
			self.msg_skycontroller.reset_zoom = False
			
	def slow_callback(self, event):	
		self.gps_fixed = bool(self.drone.get_state(olympe.messages.ardrone3.GPSSettingsState.GPSFixStateChanged)['fixed']) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_gps.html#olympe.messages.ardrone3.GPSSettingsState.GPSFixStateChanged
		self.pub_gps_fix.publish(self.gps_fixed)
			
		home = self.drone.get_state(olympe.messages.ardrone3.GPSSettingsState.HomeChanged)  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_gps.html#olympe.messages.ardrone3.GPSSettingsState.HomeChanged
		if home['latitude'] != 500 and home['longitude'] != 500 and home['altitude'] != 500: 
			msg_home_location = PointStamped()
			msg_home_location.header.stamp = rospy.Time.now()
			msg_home_location.header.frame_id = '/world'
			msg_home_location.point.x = home['latitude']
			msg_home_location.point.y = home['longitude']
			msg_home_location.point.z = home['altitude']
			self.pub_home_location.publish(msg_home_location)
							
		self.pub_battery_health.publish(self.drone.get_state(olympe.messages.battery.health)['state_of_health'])  # https://developer.parrot.com/docs/olympe/arsdkng_battery.html#olympe.messages.battery.health
				
	def run(self): 	
		rate = rospy.Rate(100)  # 100hz
		
		while not rospy.is_shutdown():
			if not self.drone.connection_state():
				rospy.logfatal('Drone disconnected!!!')
				self.disconnect()
				rospy.loginfo('Reconnecting to the drone...')
				self.connect()

			rate.sleep()


if __name__ == '__main__':
	rospy.init_node('anafi', anonymous = False)
	rospy.loginfo("Anafi_bridge is running...")
	anafi = Anafi()	
	try:
		anafi.run()
	except rospy.ROSInterruptException:
		pass
